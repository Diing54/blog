<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Diing</title>
    <link>http://localhost:1313/blog/tags/docker/</link>
    <description>Recent content in Docker on Diing</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 14 Feb 2026 21:27:43 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Containerization</title>
      <link>http://localhost:1313/blog/posts/containerization/</link>
      <pubDate>Sat, 14 Feb 2026 21:27:43 +0300</pubDate>
      <guid>http://localhost:1313/blog/posts/containerization/</guid>
      <description>&lt;p&gt;It has been a few days so far learning about containers and I&amp;rsquo;m fascinated by the advances they bring in the tech industry. Containers revolutionalized the development, testing and deployment of applications.&lt;/p&gt;&#xA;&lt;p&gt;Before containers, teams would develop applications locally on their machines and ship the application to the operations team. Developers needed to specify the dependancies together with their versions and environment configurations for this application to run successfully on other machines e.g the production servers. This would sometimes be a lot of work writing all the requirements needed for a specific application to run and on the other end, the operations team would make mistakes in configuring the environment and the app fails to run. This would lead to conflicts between the two teams with the developer saying &amp;ldquo;It was working on my end&amp;rdquo;. With containers, teams utilize an image which is a portable package which has all the requirements required to run an application and it is spun up with a container.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
